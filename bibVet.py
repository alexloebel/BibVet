#!/usr/bin/env python3

import argparse 
import json
import re
import sys

import bibtexparser
from bibtexparser.bparser import BibTexParser
from bibtexparser.bwriter import BibTexWriter 


def checkDuplicates(file):
    """ Checks for duplicates in a .bib file. 
    Done by reading the raw data of the file and counting brackets to match entries. 
    Prints a warning if there were duplicates found.
    """

    print("\n[+] Checking duplicates: ")

    openBracketCounter = 0
    presentFields = []
    
    with open(file) as rawFile: 
        for line in rawFile: 
            line = line.strip("\n")
            inEntry = False
            betweenLines = ""
            endingLine = ""
            openBracketCounter = openBracketCounter + line.count("{")
            openBracketCounter = openBracketCounter - line.count("}")

            # find every line between the opening @ and { + count the brackets to match to the closing bracket 
            if line.startswith("@") and line != "":
                startingLine = line 
                
            elif openBracketCounter == 0: 
                endingLine = line
                presentFields = [] 
            else:
                betweenLines = betweenLines + line
            
            # every line that is not the starting line can contain fields which we need to check (and remove empty lines)
            attributesStr = betweenLines + endingLine
            head , _ , _ = attributesStr.partition('=')
            attributes = head.replace(" ", "")

            for attribute in attributes.split("\n"):
                if attribute != "":
                    presentFields.append(attribute)
        
            # count occurences of present fields and warn if it occurs more often than once 
            duplicate = ""
            for field in presentFields:
                if presentFields.count(field) > 1:
                    duplicate = field 
                    presentFields.remove(field)
            
            
            if len(duplicate)>0: 
                _, _, entry_name = startingLine.partition("{")
                print("\tMultiple occurrences of ", duplicate, " in " + entry_name.replace(",",""), sep='')


def checkMandatoryFieldsAndKeywords(bibDB, conf): 
    """ Checks mandatory fields for a bibtex entry. 
    The mandatory fields should be defined in the config file. 
    Returns the bibDB without the fields that were not mandatory.
    """

    print("\n[+] Checking mandatory fields and keywords:")
    # Need to know which fields are mandatory for which entrytype, e.g. article needs an author (defined in config)
    possibleTypes = conf['ENTRYTYPE'].keys()
    mandatoryFields = dict()
    keyWords = dict()

    for bibType in possibleTypes:
        mandatoryFields[bibType] = conf['ENTRYTYPE'][bibType]['fields']
        keyWords[bibType] = conf['ENTRYTYPE'][bibType]['keywords']

    # check every entry in the given file for their required fields 
    for entry in bibDB.entries: 
        bibType = entry['ENTRYTYPE']
        # fields generated by bibtexparser need to be removed before checking which are too much 
        copyEntry = entry.copy()
        copyEntry.pop('ENTRYTYPE', None)
        copyEntry.pop('ID', None)

        # to find out which fields are missing: start with all mandatory fields and delete it from the list once seen in the bibtex file 
        missingFields = mandatoryFields[bibType].copy()
        
        # to find out which fields are too much, start with empty list and add all that are not also in the mandatory fields
        excessFields = []

        for field in copyEntry.keys(): 
            # check if mandatory field is missing and is non-empty
            if field in missingFields and copyEntry[field].replace(" ","") != "": 
                missingFields.remove(field)
            if not (field in mandatoryFields[bibType]): 
                excessFields.append(field)

            # use get to avoid KeyError if the field has no needed keywords 
            keywords = keyWords[bibType].get(field)
            if keywords is not None:
                for word in keywords: 
                    if not re.search(word, copyEntry[field], re.IGNORECASE):
                    # if copyEntry[field].find(word) == -1: 
                        print("\tKeyword '{}' not found in field '{}' of {}.".format(word, field, entry['ID']))

        if len(missingFields) > 0: 
            print("\tFields ", missingFields, " missing (or empty) in ", entry['ID'], sep='')

        if len(excessFields) > 0: 
            print("\tRemoved fields ", excessFields, " in ",  entry['ID'], sep='')

        # remove all the fields of excessFields from the entry that we found to later write the new bibtex file 
        for field in excessFields: 
            entry.pop(field, None)

    return bibDB

def checkTags(bibDB, regexString):
    """Checks whether the tag names of bib entries follow a given regex. 
    """
    print("\n[*] Checking tag syntax:")
    p = re.compile(regexString)

    all_match = True
    for entry in bibDB.entries:
        if not p.match(entry['ID']): 
            print("\t",entry['ID'], "not matching the given regex.")
            all_match = False 

    if all_match:
        print("\tAll tags match the given syntax.")
    

def main(): 
    p = argparse.ArgumentParser()
    p.add_argument("input_file", help='The original .bib file you want to sanitize.')
    p.add_argument("config", help='The config file in JSON format.')
    p.add_argument("output_file", help='Name of the new sanitized file.')

    args = p.parse_args()

    # parse original bibfile 
    with open(args.input_file) as bibFile: 
        bibDB = bibtexparser.load(bibFile)

    # parse config file 
    with open(args.config) as configFile: 
        confDB = json.load(configFile)

    checkDuplicates(args.input_file)

    bibDB = checkMandatoryFieldsAndKeywords(bibDB, confDB['read_config'])

    checkTags(bibDB, confDB['read_config']['tag_regex'])


    # write results 
    writer = BibTexWriter()
    writer.contents = ['entries']

    # use ordering that is defined in "sort_order" in the config.json file 
    writer.order_entries_by = confDB["write_config"]["sort_order"]
        
    with open(args.output_file, 'w') as resFile: 
        resFile.write(bibtexparser.dumps(bibDB, writer))


if __name__ == "__main__":
    main()


